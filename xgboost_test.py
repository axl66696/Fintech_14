# -*- coding: utf-8 -*-
"""XGBOOST_test.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kr5e1X1gtsfUDSScv8HEKMZB_g5IxADX

#下載處理好的資料
"""

f1id = '1kMA6Ddp04-hnEihtg3Hu1ElvJh__pOBJ'
f2id = '1tgPcn9Aebq6rjSmVHZb7cQy6YWlld0da'
f3id = '1w5Cpt3jHW8z979K-hsLIemoDz6iqb9Z9'

!pip3 install gdown
import gdown
url = 'https://drive.google.com/uc?id=%s'%(f1id)
output = 'train_sorted_strConverted_fillNA.csv'
gdown.download(url, output, quiet=False)

url2 = 'https://drive.google.com/uc?id=%s'%(f2id)
output2 = 'train_locdt_loctm_converted.csv'
gdown.download(url2, output2, quiet=False)

url3 = 'https://drive.google.com/uc?id=%s'%(f3id)
output3 = 'train_X_feature_normalization_onehot.csv'
gdown.download(url3, output3, quiet=False)

"""#讀入資料"""

import pandas as pd
df = pd.read_csv('train_sorted_strConverted_fillNA.csv')
df_loct = pd.read_csv('train_locdt_loctm_converted.csv')
df_X_feature = pd.read_csv('train_X_feature_normalization_onehot.csv')

df['fraud_ind'].value_counts()[1]

df['fraud_ind'].value_counts()[0]

df_loct['fraud_ind'].value_counts()[1]

df_X_feature['fraud_ind'].value_counts()[1]

"""#使用的資料

完全用原本的，使用df

將類別balance
"""

df_2 = df.sample(frac=1, random_state=42)

fraud_df = df_2.loc[df_2['fraud_ind'] == 1]
non_fraud_df = df_2.loc[df_2['fraud_ind'] == 0][:20355]

normal_distributed_df = pd.concat([fraud_df, non_fraud_df])

df_balance = normal_distributed_df.sample(frac=1, random_state=42)
# new_df
df_balance.sort_values(by=['locdt','loctm'], inplace=True)
df_balance

"""把data和time轉換，使用df_loct"""

# df_2_loct = df_loct.sample(frac=1, random_state=42)

# fraud_df_loct = df_2_loct.loc[df_2['fraud_ind'] == 1]
# non_fraud_df_loct = df_2_loct.loc[df_2['fraud_ind'] == 0][:20355]

# normal_distributed_df_loct = pd.concat([fraud_df_loct, non_fraud_df_loct])

# new_df_loct = normal_distributed_df_loct.sample(frac=1, random_state=42)
# # new_df
# new_df_loct.sort_values(by='locdt', inplace=True)
# new_df_loct

"""用300多個feature，用df_X_feature

SMOTEENN資料

#拆分資料
"""

y = df['fraud_ind']
x = df.drop('fraud_ind', axis = 1)

y_balance = df_balance['fraud_ind']
x_balance = df_balance.drop('fraud_ind', axis = 1)

y_loct = df_loct['fraud_ind']
x_loct = df_loct.drop('fraud_ind', axis = 1)

y_X_feature = df_X_feature['fraud_ind']
x_X_feature = df_X_feature.drop('fraud_ind', axis = 1)

from sklearn.model_selection import train_test_split
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, shuffle=False) #train與test資料
x_train_part, x_val, y_train_part, y_val = train_test_split(x_train, y_train, test_size=0.2, shuffle=False) #train與val資料

x_balance_train, x_balance_test, y_balance_train, y_balance_test = train_test_split(x_balance, y_balance, test_size=0.2, shuffle=False) #train與test資料
x_balance_train_part, x_balance_val, y_balance_train_part, y_balance_val = train_test_split(x_balance_train, y_balance_train, test_size=0.2, shuffle=False) #train與val資料

x_loct_train, x_loct_test, y_loct_train, y_loct_test = train_test_split(x_loct, y_loct, test_size=0.2, shuffle=False) #train與test資料
x_loct_train_part, x_loct_val, y_loct_train_part, y_loct_val = train_test_split(x_loct_train, y_loct_train, test_size=0.2, shuffle=False) #train與val資料

x_X_feature_train, x_X_feature_test, y_X_feature_train, y_X_feature_test = train_test_split(x_X_feature, y_X_feature, test_size=0.2, shuffle=False) #train與test資料
x_X_feature_train_part, x_X_feature_val, y_X_feature_train_part, y_X_feature_val = train_test_split(x_X_feature_train, y_X_feature_train, test_size=0.2, shuffle=False) #train與val資料

"""#開始訓練"""

import xgboost as xgb
from xgboost import XGBClassifier

dtrain = xgb.DMatrix(x_train_part, label=y_train_part)
dval = xgb.DMatrix(x_val, label=y_val)
dtest = xgb.DMatrix(x_test, label=y_test)

param = {'max_depth': 2, 'eta': 1, 'objective': 'binary:logistic'}
param['nthread'] = 4
param['eval_metric'] = 'auc'
evallist = [(dval, 'eval'), (dtrain, 'train')]
num_round = 100

bst = xgb.train(param, dtrain, num_round, evallist)
xgb_model = bst.save_model('0001.model')

y_pred_xgb = bst.predict(dtest)
y_pred_xgb

dtrain_balance = xgb.DMatrix(x_balance_train_part, label=y_balance_train_part)
dval_balance = xgb.DMatrix(x_balance_val, label=y_balance_val)
dtest_balance = xgb.DMatrix(x_balance_test, label=y_balance_test)

param = {'max_depth': 2, 'eta': 1, 'objective': 'binary:logistic'}
param['nthread'] = 4
param['eval_metric'] = 'auc'
evallist_balance = [(dval_balance, 'eval'), (dtrain_balance, 'train')]
num_round = 100

bst_balance = xgb.train(param, dtrain_balance, num_round, evallist_balance)
xgb_balance_model = bst_balance.save_model('0002.model')

y_balance_pred_xgb = bst_balance.predict(dtest)
y_balance_pred_xgb

dtrain_loct = xgb.DMatrix(x_loct_train_part, label=y_loct_train_part)
dval_loct = xgb.DMatrix(x_loct_val, label=y_loct_val)
dtest_loct = xgb.DMatrix(x_loct_test, label=y_loct_test)

param = {'max_depth': 2, 'eta': 1, 'objective': 'binary:logistic'}
param['nthread'] = 4
param['eval_metric'] = 'auc'
evallist_loct = [(dval_loct, 'eval'), (dtrain_loct, 'train')]
num_round = 100

bst_loct = xgb.train(param, dtrain_loct, num_round, evallist_loct)
xgb_loct_model = bst_loct.save_model('0003.model')

y_loct_pred_xgb = bst_loct.predict(dtest_loct)
y_loct_pred_xgb

dtrain_X_feature = xgb.DMatrix(x_X_feature_train_part, label=y_X_feature_train_part)
dval_X_feature = xgb.DMatrix(x_X_feature_val, label=y_X_feature_val)
dtest_X_feature = xgb.DMatrix(x_X_feature_test, label=y_X_feature_test)

param = {'max_depth': 2, 'eta': 1, 'objective': 'binary:logistic'}
param['nthread'] = 4
param['eval_metric'] = 'auc'
evallist_X_feature = [(dval_X_feature, 'eval'), (dtrain_X_feature, 'train')]
num_round = 100

bst_X_feature = xgb.train(param, dtrain_X_feature, num_round, evallist_X_feature)
xgb_X_feature_model = bst_X_feature.save_model('0004.model')

y_X_feature_pred_xgb = bst_X_feature.predict(dtest_X_feature)
y_X_feature_pred_xgb

"""# Metrics"""

from sklearn.metrics import roc_auc_score
from sklearn.metrics import f1_score
from sklearn.metrics import accuracy_score

"""XGBOOST

ROC分數
"""

roc_auc_score(y_test, y_pred_xgb)

roc_auc_score(y_test, y_balance_pred_xgb)

roc_auc_score(y_loct_test, y_loct_pred_xgb)

roc_auc_score(y_X_feature_test, y_X_feature_pred_xgb)

"""F1-score分數"""

th = 0.6  #設定threshold

f1_score(y_test,(y_pred_xgb > th).astype(int))

f1_score(y_test,(y_balance_pred_xgb > th).astype(int))

f1_score(y_loct_test,(y_loct_pred_xgb > th).astype(int))

f1_score(y_X_feature_test,(y_X_feature_pred_xgb > th).astype(int))

"""Accuracy分數"""

print('Start predicting...')

accuracy = accuracy_score(y_test,(y_pred_xgb > th).astype(int))*100
print ("Accuracy of XGBOOST is: ", accuracy)

print('Start predicting...')

accuracy = accuracy_score(y_test,(y_balance_pred_xgb > th).astype(int))*100
print ("Accuracy of XGBOOST is: ", accuracy)

print('Start predicting...')

accuracy = accuracy_score(y_loct_test,(y_loct_pred_xgb > th).astype(int))*100
print ("Accuracy of XGBOOST is: ", accuracy)

print('Start predicting...')

accuracy = accuracy_score(y_X_feature_test,(y_X_feature_pred_xgb > th).astype(int))*100
print ("Accuracy of XGBOOST is: ", accuracy)

"""precision"""

from sklearn.metrics import precision_score
from sklearn.metrics import recall_score

precision = precision_score(y_test, (y_pred_xgb > th).astype(int), zero_division=0)
print("precision : ", precision)

precision = precision_score(y_test, (y_balance_pred_xgb > th).astype(int), zero_division=0)
print("precision : ", precision)

precision = precision_score(y_loct_test, (y_loct_pred_xgb > th).astype(int), zero_division=0)
print("precision : ", precision)

precision = precision_score(y_X_feature_test, (y_X_feature_pred_xgb > th).astype(int), zero_division=0)
print("precision : ", precision)

"""recall"""

recall = recall_score(y_test, (y_pred_xgb > th).astype(int))
print("recall : ",recall)

recall = recall_score(y_test, (y_balance_pred_xgb > th).astype(int))
print("recall : ",recall)

recall = recall_score(y_loct_test, (y_loct_pred_xgb > th).astype(int))
print("recall : ",recall)

recall = recall_score(y_X_feature_test, (y_X_feature_pred_xgb > th).astype(int))
print("recall : ",recall)

"""# SMOTE"""

from imblearn.over_sampling import SMOTE

smote = SMOTE(random_state=42)
x_over,y_over = smote.fit_resample(x_train, y_train)

#before smote 
y.value_counts().plot.bar()

x.shape

type(x)

type(y)

y

y

x_over.shape

y_over.shape

y_over = pd.DataFrame(data=y_over.flatten())

print("AFTER SMOTE")
y_over.value_counts().plot.bar()

x_over.shape

x_over

from sklearn.model_selection import train_test_split
x_over_train, x_over_test, y_over_train, y_over_test = train_test_split(x_over, y_over, test_size=0.2, shuffle=False) #train與test資料
x_over_train_part, x_over_val, y_over_train_part, y_over_val = train_test_split(x_over_train, y_over_train, test_size=0.2, shuffle=False) #train與val資料

spw = 1501432 / 20355

model = XGBClassifier(max_depth=2, nthread=4, scale_pos_weight=spw, eval_metric='auc', n_estimators=10)

model.get_params

bst_class = model.fit(x_train_part, y_train_part, eval_set=[(x_val, y_val)])

y_pred = bst_class.predict(x_test)

x_train

x_over = pd.DataFrame(x_over, columns=x_train.columns)
type(x_over)

type(y_train)

type(y_over)

y_over = pd.DataFrame(y_over, columns=['fraud_ind'])
y_over

x_over

over_df = pd.concat([x_over,y_over])
over_df

over_df.sort_values(by=['locdt','loctm'], inplace=True)
over_df

dtrain_over = xgb.DMatrix(x_over, label=y_over)

# x_val = pd.DataFrame(x_val, columns=x_val.columns)
dval_over = xgb.DMatrix(x_val, label=y_val)

# x_test = pd.DataFrame(x_test, columns=x_test.columns)
dtest_over = xgb.DMatrix(x_test)

param = {'max_depth': 2, 'eta': 1, 'objective': 'binary:logistic'}
param['nthread'] = 4
param['eval_metric'] = 'auc'
evallist_over = [(dval_over, 'eval'), (dtrain_over, 'train')]
num_round = 10

bst_over = xgb.train(param, dtrain_over, num_round, evallist_over)
xgb_over_model = bst_over.save_model('0005.model')

y_over_pred_xgb = bst_over.predict(dtest)
y_over_pred_xgb

y_over_pred_xgb = bst_over.predict(dtest)
y_over_pred_xgb

f1_score(y_test,(y_pred > th).astype(int))

f1_score(y_test,(y_over_pred_xgb > th).astype(int))